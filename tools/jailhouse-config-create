#!/usr/bin/env python
#
# Jailhouse, a Linux-based partitioning hypervisor
#
# Copyright (c) Siemens AG, 2014-2017
# Copyright (c) Valentine Sinitsyn, 2014-2015
#
# Authors:
#  Henning Schild <henning.schild@siemens.com>
#  Jan Kiszka <jan.kiszka@siemens.com>
#  Valentine Sinitsyn <valentine.sinitsyn@gmail.com>
#
# This work is licensed under the terms of the GNU GPL, version 2.  See
# the COPYING file in the top-level directory.
#
# This script should help to create a basic jailhouse configuration file.
# It needs to be executed on the target machine, where it will gather
# information about the system. For more advanced scenarios you will have
# to change the generated C-code.

from __future__ import print_function
import sys
import os
import math
import re
import argparse
import struct
# Though directly unused, importing readline indirectly / automatically
# provides added abilities to input() / raw_input() (e.g. using arrow keys
# provides previous input)
import readline

try:
    from mako.template import Template
except ImportError:
    print("This script requires the mako library to run.")
    sys.exit(1)

# Imports from directory containing this must be done before the following
sys.path[0] = os.path.dirname(os.path.abspath(__file__)) + "/.."
import pyjailhouse.sysfs_parser as sysfs_parser

datadir = None

if datadir:
    template_default_dir = datadir + "/jailhouse"
else:
    template_default_dir = os.path.abspath(os.path.dirname(sys.argv[0]))

# pretend to be part of the jailhouse tool
sys.argv[0] = sys.argv[0].replace('-', ' ')

parser = argparse.ArgumentParser()
parser.add_argument('-g', '--generate-collector',
                    help='generate a script to collect input files on '
                         'a remote machine',
                    action='store_true')
parser.add_argument('-r', '--root',
                    help='gather information in ROOT/, the default is "/" '
                         'which means creating a config for localhost',
                    default='/',
                    action='store',
                    type=str)
parser.add_argument('-t', '--template-dir',
                    help='the directory where the templates are located,'
                         'the default is "' + template_default_dir + '"',
                    default=template_default_dir,
                    action='store',
                    type=str)
parser.add_argument('-c', '--console',
                    help='the name of the UART device that should be used as '
                         'primary hypervisor debug console ("ttyX" or "none")',
                    default='ttyS0',
                    action='store',
                    type=str)
parser.add_argument('--create-non-root',
                    help='In addition to creating the root cell, create '
                         'non-root cells',
                    action="store_true")

memargs = [['--mem-inmates', '76M', 'inmate'],
           ['--mem-hv', '6M', 'hypervisor']]

for entry in memargs:
    parser.add_argument(entry[0],
                        help='the amount of ' + entry[2] +
                             ' memory, default is "' + entry[1] +
                             '", format "xxx[K|M|G]"',
                        default=entry[1],
                        action='store',
                        type=str)

parser.add_argument('file', metavar='FILE',
                    help='name of file to write out',
                    type=str)

options = parser.parse_args()


def kmg_multiply(value, kmg):
    if (kmg == 'K' or kmg == 'k'):
        return 1024 * value
    if (kmg == 'M' or kmg == 'm'):
        return 1024**2 * value
    if (kmg == 'G' or kmg == 'g'):
        return 1024**3 * value
    return value


def kmg_multiply_str(str):
    m = re.match(r'([0-9a-fA-FxX]+)([KMG]?)', str)
    if m is not None:
        return kmg_multiply(int(m.group(1)), m.group(2))
    raise RuntimeError('kmg_multiply_str can not parse input "' + str + '"')


def input_readline(name, optional=False):
    f = sysfs_parser.input_open(name, optional=optional)
    line = f.readline()
    f.close()
    return line


def parse_kernel_cmdline():
    line = input_readline('/proc/cmdline')
    ma = re.findall(r'memmap=([0-9a-fA-FxX]+)([KMG]?)\$'
                    '([0-9a-fA-FxX]+)([KMG]?)', line)
    if (len(ma) == 0):
        return None
    size = kmg_multiply(int(ma[0][0], 0), ma[0][1])
    start = kmg_multiply(int(ma[0][2], 0), ma[0][3])
    if (len(ma) > 1):
        print('WARNING: Multiple "memmap" reservations in /proc/cmdline. '
              'Picking the first for jailhouse!', file=sys.stderr)

    return [start, size]


def alloc_mem(regions, size):
    mem = [0x3a000000, size]
    for r in regions:
        if (
            r.typestr == 'System RAM' and
            r.start <= mem[0] and
            r.stop + 1 >= mem[0] + mem[1]
        ):
            if r.start < mem[0]:
                head_r = sysfs_parser.MemRegion(r.start, mem[0] - 1, r.typestr,
                                                r.comments)
                regions.insert(regions.index(r), head_r)
            if r.stop + 1 > mem[0] + mem[1]:
                tail_r = sysfs_parser.MemRegion(mem[0] + mem[1], r.stop,
                                                r.typestr, r.comments)
                regions.insert(regions.index(r), tail_r)
            regions.remove(r)
            return mem
    for r in reversed(regions):
        if (r.typestr == 'System RAM' and r.size() >= mem[1]):
            mem[0] = r.start
            r.start += mem[1]
            return mem
    raise RuntimeError('failed to allocate memory')


def count_cpus():
    list = sysfs_parser.input_listdir('/sys/devices/system/cpu', ['cpu*/uevent'])
    count = 0
    for f in list:
        if re.match(r'cpu[0-9]+', f):
            count += 1
    return count


def parse_ioports():
    pm_timer_base = None
    f = sysfs_parser.input_open('/proc/ioports')
    for line in f:
        if line.endswith('ACPI PM_TMR\n'):
            pm_timer_base = int(line.split('-')[0], 16)
            break
    f.close()
    return pm_timer_base


class MMConfig:
    def __init__(self, base, end_bus):
        self.base = base
        self.end_bus = end_bus

    @staticmethod
    def parse():
        f = sysfs_parser.input_open('/sys/firmware/acpi/tables/MCFG', 'rb')
        signature = f.read(4)
        if signature != b'MCFG':
            raise RuntimeError('MCFG: incorrect input file format %s' %
                               signature)
        (length,) = struct.unpack('<I', f.read(4))
        if length > 60:
            raise RuntimeError('Multiple MMCONFIG regions found! '
                               'This is not supported')
        f.seek(44)
        (base, segment, start_bus, end_bus) = \
            struct.unpack('<QHBB', f.read(12))
        if segment != 0 or start_bus != 0:
            raise RuntimeError('Invalid MCFG structure found')
        return MMConfig(base, end_bus)


class DebugConsole:
    def __init__(self, console):
        self.address = 0
        self.pio = False
        self.dist1 = False
        if console != 'none':
            type = int(input_readline('/sys/class/tty/%s/io_type' % console,
                                      True))
            if type == 0:
                self.address = int(input_readline(
                    '/sys/class/tty/%s/port' % console, True), 16)
                self.pio = True
                self.dist1 = True
            elif type in (2, 3):
                shift = int(input_readline(
                    '/sys/class/tty/%s/iomem_reg_shift' % console, True))
                if (type == 2 and shift != 0) or (type == 3 and shift != 2):
                    print('WARNING: Unexpected UART MMIO access mode: '
                          'type=%d, shift=%d. Disabling console.' %
                          (type, shift))
                else:
                    self.address = int(input_readline(
                        '/sys/class/tty/%s/iomem_base' % console, True), 16)
                    self.pio = False
                    self.dist1 = (shift == 0)


if options.generate_collector:
    f = open(options.file, 'w')
    filelist = ' '.join(sysfs_parser.inputs['files'])
    filelist_opt = ' '.join(sysfs_parser.inputs['files_opt'])
    filelist_intel = ' '.join(sysfs_parser.inputs['files_intel'])
    filelist_amd = ' '.join(sysfs_parser.inputs['files_amd'])

    tmpl = Template(filename=os.path.join(options.template_dir,
                                          'jailhouse-config-collect.tmpl'))
    f.write(tmpl.render(filelist=filelist, filelist_opt=filelist_opt,
            filelist_intel=filelist_intel, filelist_amd=filelist_amd))
    f.close()
    sys.exit(0)

if ((options.root is '/') and (os.geteuid() is not 0)):
    print('ERROR: You have to be root to work on "/"!', file=sys.stderr)
    sys.exit(1)

jh_enabled = input_readline('/sys/devices/jailhouse/enabled', True).rstrip()
if jh_enabled == '1':
    print('ERROR: Jailhouse was enabled when collecting input files! '
          'Disable jailhouse and try again.',
          file=sys.stderr)
    sys.exit(1)

IOAPIC_MAX_PINS = 120
int_src_count = IOAPIC_MAX_PINS

sysfs_parser.root_dir = options.root

(pcidevices, pcicaps, cnt) = sysfs_parser.parse_pcidevices()

int_src_count += cnt
vtd_interrupt_limit = 2**math.ceil(math.log(int_src_count, 2))

product = [input_readline('/sys/class/dmi/id/sys_vendor',
                          True).rstrip(),
           input_readline('/sys/class/dmi/id/product_name',
                          True).rstrip()
           ]

inmatemem = kmg_multiply_str(options.mem_inmates)
hvmem = [0, kmg_multiply_str(options.mem_hv)]

(regions, dmar_regions) = sysfs_parser.parse_iomem(pcidevices)
ourmem = parse_kernel_cmdline()
total = hvmem[1] + inmatemem

mmconfig = MMConfig.parse()

ioapics = sysfs_parser.parse_madt()

vendor = sysfs_parser.get_cpu_vendor()
if vendor == 'GenuineIntel':
    (iommu_units, extra_memregs) = sysfs_parser.parse_dmar(pcidevices, ioapics,
                                                           dmar_regions)
else:
    (iommu_units, extra_memregs) = sysfs_parser.parse_ivrs(pcidevices, ioapics)
regions += extra_memregs

# kernel does not have memmap region, pick one
if ourmem is None:
    ourmem = alloc_mem(regions, total)
elif (total > ourmem[1]):
    raise RuntimeError('Your memmap reservation is too small you need >="' +
                       hex(total) + '". Hint: your kernel cmd line needs '
                       '"memmap=' + hex(total) + '$' + hex(ourmem[0]) + '"')

hvmem[0] = ourmem[0]

inmatereg = sysfs_parser.MemRegion(ourmem[0] + hvmem[1],
                                   ourmem[0] + hvmem[1] + inmatemem - 1,
                                   'JAILHOUSE Inmate Memory')
regions.append(inmatereg)

cpucount = count_cpus()

pm_timer_base = parse_ioports()

debug_console = DebugConsole(options.console)

######################################


def print_remaining_regions(remaining_regions):
    print("\nThe following region(s) of physical memory are available:\n")
    for i in range(len(remaining_regions)):
        print(str(i) + ": " + str(remaining_regions[i]))
    print("")


def get_input():  # input() in Python3 == raw_input() in Python2
    while True:
        if sys.version_info[0] == 2:
            inp = raw_input()
        else:  # version_info[0] == 3
            inp = input()

        return inp


def get_addr_input(addr_type):
    while True:
        print("\nWhat should the %s address of this "
              "region be? Please input an address in hex that lies within a "
              "64-bit addresses space, e.g. \"DEADBEEF\":" % addr_type)
        starting_addr = get_input()

        try:
            starting_addr = int(starting_addr, 16)
            if starting_addr < 0 or starting_addr > (2**64) - 1:
                print("The inputted address (%d) must doesn't fall in a "
                      "64-bit address range.\n" % starting_addr)
                continue
        except ValueError:
            print("The inputted address (%s) is not a hex string.\n" %
                  starting_addr)
            continue

        return starting_addr


def get_integer_input(prompt):
    while True:
        print(prompt)
        try:
            val = int(get_input())
            if val <= 0:
                print("Inputed value needs to be a positive integer\n")
                continue
        except ValueError:
            print("Inputed value needs to be an integer\n")
            continue

        return val


def allocate_region(remaining_regions, chosen_regions, name):
    phys_start = get_addr_input("starting physical")
    phys_end = get_addr_input("ending physical")
    virt_start = get_addr_input("starting virtual (guest physical)")

    new_reg = sysfs_parser.MemRegion(phys_start, phys_end, 'System RAM',
                                     virt_start=virt_start, comments=name)

    # =======================
    # Physical address checks
    # =======================

    if (phys_end < phys_start):
        print("The starting physical address (%08x) is greater than the "
              "ending physical address (%08x)" % (phys_start, phys_end))
        return False

    # Check to see that phyiscal addr lies within a block
    highest_p_addr_reg = -1  # Index of phys addr region we want to break up
    for i in range(len(remaining_regions)):
        if new_reg.start < remaining_regions[i].start:
            break
        highest_p_addr_reg = i

    if highest_p_addr_reg == -1:
        print("The starting address for this physical region (%08x) is "
              "less than the starting addr. of the lowest-physically "
              "addressed available region (%08x)" %
              (new_reg.start, remaining_regions[0].start))
        return False

    intersecting_p_reg = remaining_regions[highest_p_addr_reg]
    if intersecting_p_reg.stop < new_reg.stop:
        print("Selected physical region (%08x - %08x) does not lie "
              "within the bounds of a free region" %
              (phys_start, phys_end))
        return False

    # =======================
    # Virtual address checks
    # =======================

    # Check to see that v-addr doesn't intersect currently assigned block
    highest_v_addr_reg = 0  # Index of v-addr region to come after new_reg
    for i in range(len(chosen_regions)):
        l_bound_overlap = new_reg.virt_start < chosen_regions[i].virt_start + \
            chosen_regions[i].size() and chosen_regions[i].virt_start <= \
            new_reg.virt_start

        r_bound_overlap = chosen_regions[i].virt_start < new_reg.virt_start + \
            new_reg.size() and new_reg.virt_start + new_reg.size() <= \
            chosen_regions[i].virt_start + chosen_regions[i].size()

        if l_bound_overlap or r_bound_overlap:
            print("Selected virtual region (%08x - %08x) intersects an "
                  "already allocated virtual region\n" % (new_reg.virt_start,
                                                          new_reg.virt_start +
                                                          new_reg.size() - 1))
            return False

        if new_reg.virt_start + new_reg.size() <= chosen_regions[i].virt_start:
            break
        highest_v_addr_reg += 1

    # =======================
    # Create regions
    # =======================

    # Break up remaining_regions

    # We're using the entire region, delete it
    if new_reg.start == intersecting_p_reg.start and \
            new_reg.size() == intersecting_p_reg.size():
        del remaining_regions[highest_p_addr_reg:highest_p_addr_reg + 1]

    # We're using one of two endpoints of the enclosing physical region, shrink
    # the region accordingly
    elif new_reg.start == intersecting_p_reg.start:
        intersecting_p_reg.start += new_reg.size()

    elif new_reg.start + new_reg.size() == intersecting_p_reg.start + \
            intersecting_p_reg.size():
        intersecting_p_reg.stop = new_reg.start - 1

    # The requested region uses neither endpoint of the containing region,
    # break it up into two new regions
    else:
        new_phys_reg = sysfs_parser.MemRegion(intersecting_p_reg.start,
                                              new_reg.start - 1,
                                              'System RAM', comments=name,
                                              virt_start=virt_start)
        remaining_regions.insert(highest_p_addr_reg, new_phys_reg)
        intersecting_p_reg.start = new_reg.stop + 1

    # Add a new block to chosen_regions (sorted by v-addr)
    chosen_regions.insert(highest_v_addr_reg, new_reg)

    return True


if options.create_non_root:
    still_creating_cell = True
    available_cpus = set([i for i in range(cpucount)])
    # Array of physical regions a guest can use for RAM. Last element of
    # regions array contains memory set aside for guest RAM.
    remaining_regions = [regions[-1]]
    remaining_regions[0].typestr = "System RAM"
    used_names = []

    while still_creating_cell:
        name = ""
        cpu_bitmaps = []  # Array of CPU bitmap strings
        chosen_regions = []  # Array of memory (for RAM) reserved for a guest
                             # TODO/ note: currently ordered by virtual address
                             # due to the way array is used in allocate_region

        # Choose name
        print("\n=======\nName\n=======")
        while True:
            print("Enter a unique name for this cell:")
            name = get_input()
            if name in used_names:
                print("%s is already in use as a cell name" % name)
                continue
            used_names.append(name)
            break

        print("\n=======\nCPU Set\n=======")
        # Get CPUs
        while True:
            cpu_ids_correct = True
            print("The following CPUs are available:")
            print(available_cpus)
            print("Enter a comma separated list of the ones you want - "
                  "'..' can be used to indicate a range of cpus (e.g., "
                  "'0..3, 7' is equivalent to '0, 1, 2, 3, 7'):")
            cpu_ids = get_input().split(",")

            # Expand all ranges, make sure all inputs are integers
            for i in range(len(cpu_ids) - 1, -1, -1):
                try:
                    if ".." in cpu_ids[i]:
                        arr = cpu_ids[i].split("..")
                        cpu_ids += range(int(arr[0]), int(arr[1]) + 1)
                        del cpu_ids[i:i+1]
                    else:
                        int(cpu_ids[i])

                except ValueError:
                    print("Entered CPU ID / range (%s) has non-integer "
                          "values" % cpu_ids[i])
                    cpu_ids_correct = False
                    break

            # cpu_ids now a list of integers, check that intersection of
            # cpu_ids and available_cpus is non-empty, then reserve CPUs
            # in intersection
            if cpu_ids_correct:
                cpu_ids = set([int(cpu_id) for cpu_id in cpu_ids]) & \
                    available_cpus

                if len(cpu_ids) == 0:
                    print("None of the CPUs you chose are available.")
                    continue

                available_cpus = available_cpus - cpu_ids

                # Create needed number of 16 hex digit bitmaps indicating
                # CPUs are in use
                chosen_cpus = 0
                for cpu in cpu_ids:
                    chosen_cpus += 2**cpu

                while chosen_cpus != 0:
                    cpu_bitmaps.append('0x%016x' % (chosen_cpus % 2**64))
                    chosen_cpus = chosen_cpus // (2**64)

                break

        # Get RAM
        print("\n=======\nRAM\n=======")
        print_remaining_regions(remaining_regions)

        num_regions = get_integer_input("How many regions would you like "
                                        "to create from it (must select "
                                        "at least one region)?")

        for i in range(num_regions):
            print("\n=======\nRegion %d\n=======" % (i + 1))
            print("Choose a name for this region (optional, only appears "
                  "as comment in generated file):")
            region_name = get_input()

            while True:
                if allocate_region(remaining_regions, chosen_regions,
                                   region_name):
                    break

            if len(remaining_regions) == 0:
                break

            print_remaining_regions(remaining_regions)

        # Write out config
        with open(name + ".c", 'w') as f:
            tmpl = Template(filename=os.path.join(options.template_dir,
                            'non-root-cell-config.c.tmpl'))
            kwargs = {
                'name': name,
                'cpu_bitmaps': cpu_bitmaps,
                'chosen_mem_regions': chosen_regions
            }
            f.write(tmpl.render(**kwargs))

        # Check for resources - if they're all exhausted, exit
        if len(available_cpus) == 0:
            print("All CPUs are now marked as reserved, finishing")
            break

        if len(remaining_regions) == 0:
            print("All inmate RAM is now depleted, finishing")
            break

        while True:
            print("\nWould you like to create another non-root cell [y/n]")
            s = get_input().lower()
            if s != "y" and s != "n":
                continue
            if s == "n":
                still_creating_cell = False
            print("")
            break

######################################

# Write out root cell
with open(options.file, 'w') as f:
    tmpl = Template(filename=os.path.join(options.template_dir,
                                          'root-cell-config.c.tmpl'))
    kwargs = {
        'regions': regions,
        'ourmem': ourmem,
        'argstr': ' '.join(sys.argv),
        'hvmem': hvmem,
        'product': product,
        'pcidevices': pcidevices,
        'pcicaps': pcicaps,
        'cpucount': cpucount,
        'irqchips': ioapics,
        'pm_timer_base': pm_timer_base,
        'vtd_interrupt_limit': vtd_interrupt_limit,
        'mmconfig': mmconfig,
        'iommu_units': iommu_units,
        'debug_console': debug_console,
    }

    f.write(tmpl.render(**kwargs))
